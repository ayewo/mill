//// SNIPPET:BUILD
package build
import mill._, javalib._
import mill.javalib.Assembly._
import mill.scalalib.JpackageModule

object foo extends JavaModule with JpackageModule {
  def jpackageType = "pkg"

  def assemblyRules = Seq(
    // all application.conf files will be concatenated into single file
    Rule.Append("application.conf"),
    // all *.conf files will be concatenated into single file
    Rule.AppendPattern(".*\\.conf")
  )
}
//// SNIPPET:END

// This example illustrates how to use Mill to generate a native package/installer
// using the `jpackage` tool.

// JPMS (Java Platform Module System) is a modern distribution format that was designed
// to avoid several of the shortcomings of the ubiquitous JAR format, especially "JAR Hell".

// A defining characteristic of module-based Java applications based on the JPMS format
// is that a `module-info.java` must be defined at the root of the moduleâ€™s source-file hierarchy.
// The `module-info.java` must explicitly list modules that it depends on, and also list
// packages that it exports, to make the integrity of these relationships easy to verify,
// both at compile-time and run-time.

// Starting with version 14, the JDK now ships with the `jpackage` tool which can
// assemble any module-based Java application into a native package/installer.

// The above build file expects the following project layout:
//
//// SNIPPET:TREE
//
// ----
// build.mill
// foo/
//     src/
//         Foo.java
//         Bar.java
//
//     module-info.java
// ----
//
//// SNIPPET:END

// The build defines a `foo` module that uses the `trait JpackageModule`.

// NOTE: Mill also uses the term `Module` for traits xref:fundamentals/modules.adoc[Trait Module].
// This is not to be confused with Java application code structured as modules according to the JPMS format.

// The `JpackageModule` trait will infer most of the options needed to assemble a native
// package/installer, but you can still customize its output. In our example, we specified:

// def jpackageType = "pkg"

// This tells `jpackage` to generate a `.pkg`, which is the native installer format on macOS.
// Valid values on macOS are: `dmg`, `pkg` and `app-image`.

// NOTE: `jpackage` doesn't not support cross-targeting. Cross-targeting in this
// context means the `jpackage` binary shipped with a macOS JDK
// cannot be used to produce a binary package for another OS like Windows or Linux.

/** Usage

> mill foo.assembly

> unzip -p ./out/foo/assembly.dest/out.jar application.conf
Foo Application Conf

> java -jar ./out/foo/assembly.dest/out.jar
Nov 28, 2024 12:45:43 PM foo.Foo readConf
INFO: Loaded application.conf from resources: Foo Application Conf

Nov 28, 2024 12:45:44 PM foo.Bar lambda$main$0
INFO: Hello World application started successfully


> mill show foo.jpackageAppImage
".../out/foo/jpackageAppImage.dest/image"


// jpackageType accepts 3 values on macOS: "dmg" or "pkg" or "app-image" (default).
// macOS: jpackageType = "dmg"
> ls -l ./out/foo/jpackageAppImage.dest/image
-rw-r--r--@ 1 mac  staff  60686513 Nov 28 12:36 foo-1.0.dmg

// macOS: jpackageType = "pkg"
> ls -l ./out/foo/jpackageAppImage.dest/image
total 106360
-rw-r--r--  1 mac  staff  54460727 Nov 28 12:40 foo-1.0.pkg

// macOS: jpackageType = "app-image"
> ls -l ./out/foo/jpackageAppImage.dest/image
drwxr-xr-x  3 mac  staff  96 Nov 28 12:34 foo.app/

> ./out/foo/jpackageAppImage.dest/image/foo.app/Contents/MacOS/foo 
Nov 28, 2024 12:31:46 PM foo.Foo readConf
INFO: Loaded application.conf from resources: Foo Application Conf

Nov 28, 2024 12:31:46 PM foo.Bar lambda$main$0
INFO: Hello World application started successfully

*/
